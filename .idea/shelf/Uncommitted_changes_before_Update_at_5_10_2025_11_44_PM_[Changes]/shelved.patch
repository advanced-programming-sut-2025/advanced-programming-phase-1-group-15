Index: src/main/java/models/npcs/NPCFriendShip.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package models.npcs;\r\n\r\npublic class NPCFriendShip {\r\n    private int points = 0;\r\n    private boolean talkedToday = false;\r\n    private boolean giftedToday = false;\r\n\r\n    static final int MAX_POINTS = 799;\r\n    static final int POINTS_PER_LEVEL = 200;\r\n\r\n    void addPoints(int points) {\r\n        this.points += points;\r\n        if(points > MAX_POINTS) {\r\n            this.points = MAX_POINTS;\r\n        }\r\n    }\r\n\r\n    int getLevel() {\r\n        return points / POINTS_PER_LEVEL;\r\n    }\r\n\r\n    boolean hasTalkedToday() {\r\n        return talkedToday;\r\n    }\r\n\r\n    boolean hasGiftedToday() {\r\n        return giftedToday;\r\n    }\r\n\r\n    void markTalked() {\r\n        talkedToday = true;\r\n    }\r\n\r\n    void markGifted() {\r\n        giftedToday = true;\r\n    }\r\n\r\n    void resetDaily() {\r\n        talkedToday = false;\r\n        giftedToday = false;\r\n    }\r\n\r\n\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/models/npcs/NPCFriendShip.java b/src/main/java/models/npcs/NPCFriendShip.java
--- a/src/main/java/models/npcs/NPCFriendShip.java	(revision c85905f21fa3eabeda08b22f497a86c9a08cda43)
+++ b/src/main/java/models/npcs/NPCFriendShip.java	(date 1746907618266)
@@ -1,6 +1,19 @@
 package models.npcs;
 
+import models.Player;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
 public class NPCFriendShip {
+    NPC npc;
+    Player player;
+
+    public NPCFriendShip(NPC npc, Player player) {
+        this.npc = npc;
+        this.player = player;
+    }
+
     private int points = 0;
     private boolean talkedToday = false;
     private boolean giftedToday = false;
@@ -8,6 +21,8 @@
     static final int MAX_POINTS = 799;
     static final int POINTS_PER_LEVEL = 200;
 
+    private HashMap<Quest,Boolean> playerQuests = new HashMap<>();
+
     void addPoints(int points) {
         this.points += points;
         if(points > MAX_POINTS) {
@@ -40,6 +55,25 @@
         giftedToday = false;
     }
 
+    void activateQuests() {
+        int lvl = getLevel();
+        for (Quest quest : npc.questTemplates.keySet())  {
+            if (!playerQuests.containsKey(quest) && lvl >= npc.questTemplates.get(quest)) {
+                playerQuests.put(quest, true);
+            }
+        }
+    }
+
+    void showQuests(Player player) {
+        StringBuilder sj = new StringBuilder("\n");
+        for (Quest pq : playerQuests.keySet()) {
+            if (playerQuests.get(pq)) {
+                sj.append("Deliver " + pq.getRequestAmount() +
+                        " x " + pq.getRequest().getName());
+            }
+        }
+    }
+
 
 }
 
Index: src/main/java/controllers/GameMenuController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controllers;\r\n\r\nimport models.App;\r\nimport models.Game;\r\nimport models.Player;\r\nimport models.Result;\r\nimport models.animals.*;\r\nimport models.artisanry.ArtisanItem;\r\nimport models.artisanry.ArtisanItemType;\r\nimport models.cooking.Food;\r\nimport models.crafting.CraftItem;\r\nimport models.farming.*;\r\nimport models.farming.GeneralPlants.PloughedPlace;\r\nimport models.map.*;\r\nimport models.stores.CarpenterShop;\r\nimport models.stores.MarnieRanch;\r\nimport models.stores.Store;\r\nimport models.tools.*;\r\n\r\npublic class GameMenuController {\r\n    public static Player getCurrentPlayer() {\r\n        return App.currentGame.getCurrentPlayer();\r\n    }\r\n    \r\n    public static Result walk(int x, int y) {\r\n        if(x >= Map.COLS || y >= Map.ROWS || x < 0 || y < 0) {\r\n            return new Result(false, \"you are out of bounds!\");\r\n        }\r\n\r\n        Tile tile = App.currentGame.getTile(x, y);\r\n        if(!tile.isEmpty()) {\r\n            return new Result(false, \"you can't stand on a tile which is not empty.\");\r\n        }\r\n        else if(tile.getAreaType().equals(AreaType.LAKE)) {\r\n            return new Result(false, \"you're destination is in the lake!\");\r\n        }\r\n        else if(tile.getAreaType().equals(AreaType.FARM)) {\r\n            Farm farm = (Farm) tile.getArea();\r\n            if(!getCurrentPlayer().equals(farm.getOwner())) {\r\n                return new Result(false, \"you cannot enter other players' territory.\");\r\n            }\r\n        }\r\n\r\n        int energyNeeded = getCurrentPlayer().calculateWalkingEnergy(new Position(x, y));\r\n\r\n        if(energyNeeded == -1) {\r\n            return new Result(false, \"tile is unreachable!\");\r\n        }\r\n        return new Result(true, energyNeeded + \" energy would be consumed. Do you agree? (y/n)\");\r\n    }\r\n\r\n    public static Result setPosition(int x, int y) {\r\n        Position position = new Position(x, y);\r\n\r\n        getCurrentPlayer().walk(position);\r\n        if(getCurrentPlayer().isFainted()) {\r\n            return new Result(false, \"Oops! you've fainted!\");\r\n        }\r\n\r\n        return new Result(true, \"moved to position \" + position + \" successfully.\");\r\n    }\r\n\r\n    public static Result removeFromInventory(String itemName, int count) {\r\n        BackPackable item = getCurrentPlayer().getInventory().getItemByName(itemName);\r\n        int availableCount = getCurrentPlayer().getInventory().getItemCount(itemName);\r\n        if(item == null) {\r\n            return new Result(false, \"You don't have that item.\");\r\n        }\r\n        else if(count > availableCount) {\r\n            return new Result(false, \"You only have \" + availableCount + \" \" + item.getName() + \" in your inventory.\");\r\n        }\r\n\r\n        TrashCan trashCan = getCurrentPlayer().getTrashCan();\r\n        if(count == -1) {\r\n            int returnedAmount = trashCan.use(item, availableCount, getCurrentPlayer());\r\n            getCurrentPlayer().getInventory().removeFromBackPack(item);\r\n            return new Result(true, item.getName() + \" moved to trash can.\\n\" +\r\n                    returnedAmount + \" gold added to your account.\");\r\n        }\r\n        else {\r\n            int returnedAmount = trashCan.use(item, count, getCurrentPlayer());\r\n            getCurrentPlayer().getInventory().removeCountFromBackPack(item, count);\r\n            return new Result(true, count + \" \" + item.getName() + \" moved to trash can.\\n\" +\r\n                    returnedAmount + \" gold added to your account.\");\r\n        }\r\n    }\r\n\r\n    public static Result equipTool(String toolName) {\r\n        Tool tool = (Tool) getCurrentPlayer().getInventory().getItemByName(toolName);\r\n\r\n        if(tool == null) {\r\n            return new Result(false, \"You don't have that tool.\");\r\n        }\r\n\r\n        getCurrentPlayer().setCurrentTool(tool);\r\n        return new Result(true, \"equipped tool \" + tool.getName() + \" successfully.\");\r\n    }\r\n    public static Result showCurrentTool() {\r\n        Tool tool = getCurrentPlayer().getCurrentTool();\r\n        if(tool == null) {\r\n            return new Result(false, \"you're not holding any tool!\");\r\n        }\r\n\r\n        return new Result(true, tool.getName());\r\n    }\r\n    public static Result upgradeTool(String toolName) {\r\n        Tool tool = (Tool) getCurrentPlayer().getInventory().getItemByName(toolName);\r\n\r\n        if(tool == null) {\r\n            return new Result(false, \"You don't have that tool.\");\r\n        }\r\n\r\n        return new Result(true, \"Tool upgraded successfully.\");\r\n    }\r\n    public static Result useTool(int dx, int dy) {\r\n        Tool tool = getCurrentPlayer().getCurrentTool();\r\n        if(tool == null) {\r\n            return new Result(false, \"choose a tool first\");\r\n        }\r\n        Position usePosition = new Position(getCurrentPlayer().getPosition().x + dx, getCurrentPlayer().getPosition().y + dy);\r\n        if(!Map.isBoundValid(usePosition)) {\r\n            return new Result(false, \"you are out of bounds!\");\r\n        }\r\n\r\n        Tile useTile = App.currentGame.getTile(usePosition);\r\n\r\n        return new Result(true, tool.use(useTile, getCurrentPlayer()));\r\n    }\r\n\r\n    public static Result putInFridge(String itemName) {\r\n        Tile tile = App.currentGame.getTile(getCurrentPlayer().getPosition());\r\n        if(!(tile.getArea() instanceof House playersHouse)) {\r\n            return new Result(false, \"you should be in your house to use fridge!\");\r\n        }\r\n        Fridge fridge = playersHouse.getFridge();\r\n\r\n        BackPackable item = getCurrentPlayer().getInventory().getItemByName(itemName);\r\n        if(item == null) {\r\n            return new Result(false, \"You don't have that item in your inventory.\");\r\n        }\r\n\r\n        int itemCount = getCurrentPlayer().getInventory().getItemCount(itemName);\r\n        fridge.addToFridge(item, itemCount);\r\n        getCurrentPlayer().getInventory().removeFromBackPack(item);\r\n\r\n        return new Result(true, item.getName() + \" moved to fridge.\");\r\n    }\r\n    public static Result pickFromFridge(String itemName) {\r\n        Tile tile = App.currentGame.getTile(getCurrentPlayer().getPosition());\r\n        if(!(tile.getArea() instanceof House playersHouse)) {\r\n            return new Result(false, \"you should be in your house to use fridge!\");\r\n        }\r\n        Fridge fridge = playersHouse.getFridge();\r\n\r\n        BackPackable item = fridge.getItemByName(itemName);\r\n        if(item == null) {\r\n            return new Result(false, \"You don't have that item in your fridge.\");\r\n        }\r\n\r\n        int itemCount = fridge.getItemCount(itemName);\r\n        getCurrentPlayer().getInventory().addToBackPack(item, itemCount);\r\n        fridge.removeFromFridge(item);\r\n\r\n        return new Result(true, item.getName() +  \" moved to inventory.\");\r\n    }\r\n    public static Result eatFood(String foodName) {\r\n        Food food = (Food) getCurrentPlayer().getInventory().getItemByName(foodName);\r\n        if(food == null) {\r\n            return new Result(false, \"You don't have that food.\");\r\n        }\r\n\r\n        getCurrentPlayer().eat(food);\r\n        getCurrentPlayer().getInventory().removeCountFromBackPack(food, 1);\r\n        return new Result(true, \"You ate \" + food.getName() + \". \" + food.getEnergy() + \" energy added.\");\r\n    }\r\n\r\n    public static Result buildBarn(int x, int y) {\r\n        Tile playerTile = App.currentGame.getTile(getCurrentPlayer().getPosition());\r\n        if(!(playerTile.getArea() instanceof CarpenterShop)) {\r\n            return new Result(false, \"you should be inside carpenter shop to run this command.\");\r\n        }\r\n\r\n        boolean buildable = true;\r\n        for(int row = y; row < y + 2; row++) {\r\n            for(int col = x; col < x + 2; col++) {\r\n                Tile tile = App.currentGame.getTile(col, row);\r\n                if(!tile.isBuildable()) {\r\n                    buildable = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!buildable) {\r\n            return new Result(false, \"You can't build a barn in this Area.\");\r\n        }\r\n        else {\r\n            Barn barn = new Barn();\r\n            for(int row = y; row < y + 2; row++) {\r\n                for(int col = x; col < x + 2; col++) {\r\n                    Tile tile = App.currentGame.getTile(col, row);\r\n                    tile.setArea(barn);\r\n                }\r\n            }\r\n            return new Result(true, \"barn built successfully.\");\r\n        }\r\n    }\r\n    public static Result buildCoop(int x, int y) {\r\n        Tile playerTile = App.currentGame.getTile(getCurrentPlayer().getPosition());\r\n        if(!(playerTile.getArea() instanceof CarpenterShop)) {\r\n            return new Result(false, \"you should be inside carpenter shop to run this command.\");\r\n        }\r\n\r\n        boolean buildable = true;\r\n        for(int row = y; row < y + 2; row++) {\r\n            for(int col = x; col < x + 2; col++) {\r\n                Tile tile = App.currentGame.getTile(col, row);\r\n                if(!tile.isBuildable()) {\r\n                    buildable = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!buildable) {\r\n            return new Result(false, \"You can't build a coop in this Area.\");\r\n        }\r\n        else {\r\n            Coop coop = new Coop();\r\n            for(int row = y; row < y + 2; row++) {\r\n                for(int col = x; col < x + 2; col++) {\r\n                    Tile tile = App.currentGame.getTile(col, row);\r\n                    tile.setArea(coop);\r\n                }\r\n            }\r\n            return new Result(true, \"coop built successfully.\");\r\n        }\r\n    }\r\n    public static Result buyAnimal(String animalType, String name) {\r\n        Tile playerTile = App.currentGame.getTile(getCurrentPlayer().getPosition());\r\n        if(!(playerTile.getArea() instanceof MarnieRanch)) {\r\n            return new Result(false, \"you have to be inside marnie's ranch to run this command.\");\r\n        }\r\n\r\n        Animal animal = Animal.animalFactory(animalType, name);\r\n        if(animal == null) {\r\n            return new Result(false, \"invalid animal type!\");\r\n        }\r\n\r\n        for(Animal playerAnimal : getCurrentPlayer().getAnimals()) {\r\n            if(animal.getName().equals(playerAnimal.getName())) {\r\n                return new Result(false, \"each animal must have a unique name.\");\r\n            }\r\n        }\r\n\r\n        boolean placed = getCurrentPlayer().getFarm().place(animal);\r\n\r\n        if(placed) {\r\n            App.currentGame.getDateAndTime().addObserver(animal);\r\n            getCurrentPlayer().getAnimals().add(animal);\r\n            getCurrentPlayer().subtractGold(animal.getBasePrice());\r\n\r\n            return new Result(true, \"a new \" + animal.getAnimalTypeName() + \" named \" + animal.getName() + \" has been bought.\");\r\n        }\r\n        else {\r\n            return new Result(false, \"not enough \" + animal.getMaintenance() + \" space to buy this animal.\");\r\n        }\r\n    }\r\n    public static Result petAnimal(String name) {\r\n        Animal animal = getCurrentPlayer().getAnimalByName(name);\r\n\r\n        if(animal == null) {\r\n            return new Result(false, \"animal name is not correct.\");\r\n        }\r\n        else if(!getCurrentPlayer().getPosition().isAdjacent(animal.getPosition())) {\r\n            return new Result(false, \"your position is not adjacent!\");\r\n        }\r\n\r\n        animal.pet();\r\n        return new Result(true, \"you pet \" + animal.getName() + \".\");\r\n    }\r\n    public static Result shepherdAnimal(String name, int x, int y) {\r\n        Animal animal = getCurrentPlayer().getAnimalByName(name);\r\n        if(animal == null) {\r\n            return new Result(false, \"animal name is not correct.\");\r\n        }\r\n\r\n        if(x >= Map.COLS || y >= Map.ROWS || x < 0 || y < 0) {\r\n            return new Result(false, \"invalid x or y!\");\r\n        }\r\n\r\n        Tile tile = App.currentGame.getTile(x, y);\r\n        if(!App.currentGame.getWeather().couldShepherdAnimals()) {\r\n            return new Result(false, \"you cannot shepherd animals in this weather!\");\r\n        }\r\n        else if(!tile.isEmpty()) {\r\n            return new Result(false, \"animal can't stand on a tile which is not empty.\");\r\n        }\r\n        else if(tile.getAreaType().equals(AreaType.LAKE) && !animal.getAnimalType().equals(AnimalType.DUCK)) {\r\n            return new Result(false, \"only ducks can swim.\");\r\n        }\r\n        else if(tile.getAreaType().equals(AreaType.BARN) && !animal.getMaintenance().equals(Maintenance.BARN)) {\r\n            return new Result(false, \"you can't put a \" + animal.getAnimalType() + \" in a barn.\");\r\n        }\r\n        else if(tile.getAreaType().equals(AreaType.COOP) && !animal.getMaintenance().equals(Maintenance.COOP)) {\r\n            return new Result(false, \"you can't put a \" + animal.getAnimalType() + \" in a coop.\");\r\n        }\r\n        else if(tile.getAreaType().equals(AreaType.FARM)) {\r\n            Farm farm = (Farm) tile.getArea();\r\n            if(!getCurrentPlayer().equals(farm.getOwner())) {\r\n                return new Result(false, \"your animals cannot enter other players' territory.\");\r\n            }\r\n        }\r\n\r\n        Tile initialTile = App.currentGame.getTile(animal.getPosition());\r\n        animal.setPosition(tile.getPosition());\r\n\r\n        tile.put(animal);\r\n        initialTile.empty();\r\n\r\n        animal.feed();\r\n        return new Result(true, \"shepherd \" + animal.getName() + \" successfully.\");\r\n    }\r\n    public static Result feedHayAnimal(String name) {\r\n        Animal animal = getCurrentPlayer().getAnimalByName(name);\r\n        if(animal == null) {\r\n            return new Result(false, \"animal name is not correct.\");\r\n        }\r\n        else if(!getCurrentPlayer().getPosition().isAdjacent(animal.getPosition())) {\r\n            return new Result(false, \"your position is not adjacent!\");\r\n        }\r\n\r\n        animal.feed();\r\n        return new Result(true, animal.getName() + \" fed with hay.\");\r\n    }\r\n    public static Result showAnimalProducts() {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"Available animal products: \\n\");\r\n        for(Animal animal : getCurrentPlayer().getAnimals()) {\r\n            if(animal.getCurrentProduct() != null) {\r\n                sb.append(animal.getName()).append(\"    \");\r\n                sb.append(animal.getCurrentProduct().getName()).append(\"  quality: \");\r\n                sb.append(animal.getCurrentProduct().getProductQuality()).append(\"\\n\");\r\n            }\r\n        }\r\n\r\n        return new Result(true, sb.toString());\r\n    }\r\n    public static Result collectProduce(String name) {\r\n        Animal animal = getCurrentPlayer().getAnimalByName(name);\r\n        if(animal == null) {\r\n            return new Result(false, \"animal name is not correct.\");\r\n        }\r\n        else if(!getCurrentPlayer().getPosition().isAdjacent(animal.getPosition())) {\r\n            return new Result(false, \"your position is not adjacent!\");\r\n        }\r\n\r\n        else if(animal.getCurrentProduct() == null) {\r\n            return new Result(false, \"no product is available for this animal!\");\r\n        }\r\n        else if(animal.getAnimalType().equals(AnimalType.COW) || animal.getAnimalType().equals(AnimalType.GOAT)) {\r\n            return new Result(false, \"you have to use milk pail to collect these products.\");\r\n        }\r\n        else if(animal.getAnimalType().equals(AnimalType.SHEEP)) {\r\n            return new Result(false, \"you have to use shear to collect this product.\");\r\n        }\r\n        getCurrentPlayer().getInventory().addToBackPack(animal.getCurrentProduct(), 1);\r\n        animal.setCurrentProduct(null);\r\n\r\n        return new Result(true, \"product added to the inventory.\");\r\n    }\r\n    public static Result sellAnimal(String name) {\r\n        Animal animal = getCurrentPlayer().getAnimalByName(name);\r\n        if(animal == null) {\r\n            return new Result(false, \"animal name is not correct.\");\r\n        }\r\n        Tile animalTile = App.currentGame.getTile(animal.getPosition());\r\n\r\n        App.currentGame.getDateAndTime().removeObserver(animal);\r\n        getCurrentPlayer().getAnimals().remove(animal);\r\n        getCurrentPlayer().addGold(animal.getPrice());\r\n        animalTile.empty();\r\n\r\n        return new Result(true,  animal.getName() + \" has been sold with price \" + animal.getPrice());\r\n    }\r\n    public static Result fishing(String material) {\r\n        Lake lake = null;\r\n        for(int row = getCurrentPlayer().getPosition().y - 1; row <= getCurrentPlayer().getPosition().y + 1; row++) {\r\n            for(int col = getCurrentPlayer().getPosition().x - 1; col <= getCurrentPlayer().getPosition().x + 1; col++) {\r\n                if(App.currentGame.getTile(col, row).getArea() instanceof Lake) {\r\n                    lake = (Lake) App.currentGame.getTile(col, row).getArea();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(lake == null) {\r\n            return new Result(false, \"You need to stand adjacent to lake.\");\r\n        }\r\n        else {\r\n            FishingPole fishingPole = getCurrentPlayer().getInventory().getFishingPole(material);\r\n\r\n            if(fishingPole == null) {\r\n                return new Result(false, \"fishing pole not found.\");\r\n            }\r\n\r\n            return new Result(true, fishingPole.use(lake, getCurrentPlayer(), App.currentGame.getWeather().getCurrentWeather()));\r\n        }\r\n    }\r\n\r\n    public static Result showStoreProducts() {\r\n        Tile playerTile = App.currentGame.getTile(getCurrentPlayer().getPosition());\r\n\r\n        if(!playerTile.getAreaType().equals(AreaType.STORE)) {\r\n            return new Result(false, \"You need to be in a store to run this command.\");\r\n        }\r\n\r\n        Store store = (Store) playerTile.getArea();\r\n        if(!store.isOpen(App.currentGame.getDateAndTime().getHour())) {\r\n            return new Result(false, \"store is closed now!\");\r\n        }\r\n\r\n        return new Result(true, \"All Items: \\n\" + store.displayItems());\r\n    }\r\n    public static Result showAvailableStoreProducts() {\r\n        Tile playerTile = App.currentGame.getTile(getCurrentPlayer().getPosition());\r\n\r\n        if(!playerTile.getAreaType().equals(AreaType.STORE)) {\r\n            return new Result(false, \"You need to be in a store to run this command.\");\r\n        }\r\n\r\n        Store store = (Store) playerTile.getArea();\r\n        if(!store.isOpen(App.currentGame.getDateAndTime().getHour())) {\r\n            return new Result(false, \"store is closed now!\");\r\n        }\r\n\r\n        return new Result(true, \"All Available Items Fot You: \\n\" + store.displayAvailableItems());\r\n    }\r\n    public static Result purchaseProduct(String productName, int count) {\r\n        Tile playerTile = App.currentGame.getTile(getCurrentPlayer().getPosition());\r\n\r\n        if(!playerTile.getAreaType().equals(AreaType.STORE)) {\r\n            return new Result(false, \"You need to be in a store to run this command.\");\r\n        }\r\n\r\n        Store store = (Store) playerTile.getArea();\r\n        if(!store.isOpen(App.currentGame.getDateAndTime().getHour())) {\r\n            return new Result(false, \"store is closed now!\");\r\n        }\r\n\r\n        if(!store.checkAvailable(productName)) {\r\n            return new Result(false, \"product is not available!\");\r\n        }\r\n        else if(!store.checkAmount(productName, count)) {\r\n            return new Result(false, \"daily limit exceeded!\");\r\n        }\r\n\r\n        return new Result(true, store.sell(getCurrentPlayer(), productName, count));\r\n    }\r\n    public static Result sellProduct(String productName, int count) {\r\n        BackPackable item = getCurrentPlayer().getInventory().getItemByName(productName);\r\n        int availableCount = getCurrentPlayer().getInventory().getItemCount(productName);\r\n\r\n        if(item == null) {\r\n            return new Result(false, \"You don't have that item.\");\r\n        }\r\n        else if(count > availableCount) {\r\n            return new Result(false, \"You only have \" + availableCount + \" \" + item.getName() + \" in your inventory.\");\r\n        }\r\n        else if(item.getPrice() == 0) {\r\n            return new Result(false, \"this item is not sellable.\");\r\n        }\r\n\r\n        if(availableCount == -1) {\r\n            getCurrentPlayer().addGold(availableCount * item.getPrice());\r\n            getCurrentPlayer().getInventory().removeFromBackPack(item);\r\n            return new Result(true, \"Sold all of your \" + item.getName() + \". You earned \" + availableCount * item.getPrice() + \"gold.\");\r\n        }\r\n        else {\r\n            getCurrentPlayer().addGold(count * item.getPrice());\r\n            getCurrentPlayer().getInventory().removeCountFromBackPack(item, count);\r\n            return new Result(true, \"Sold \" + count + \" of your \" + item.getName() + \". You earned \" + count * item.getPrice() + \"gold.\");\r\n        }\r\n    }\r\n\r\n    public static Result showCropInfo(String name) {\r\n        Crops crop = Crops.getByName(name);\r\n        if(crop == null)\r\n            return new Result(false,\"no crop with this name exists!\");\r\n        return new Result(true,crop.toString());\r\n    }\r\n\r\n    public static Result plant(String seedName, int dx, int dy) {\r\n        Game current = App.currentGame;\r\n        int nextX = current.getCurrentPlayer().getPosition().x + dx;\r\n        int nextY = current.getCurrentPlayer().getPosition().y + dy;\r\n\r\n        if(dx==0 && dy==0) {return new Result(false,\"this is not a valid direction!\");}\r\n\r\n        if(nextX>Map.COLS||nextY>Map.ROWS||nextX<0||nextY<0) {\r\n            return new Result(false,\"you are going out of bounds!\");}\r\n\r\n        Tile goalTile = App.currentGame.getMap().getTile(new Position(nextX,nextY));\r\n\r\n        if(!goalTile.getObjectInTile().getClass().equals(PloughedPlace.class))\r\n            return new Result(false,\"you should plough the tile first!\");\r\n\r\n        PloughedPlace tobeSeeded = (PloughedPlace) goalTile.getObjectInTile();\r\n\r\n        if(CropSeeds.getByName(seedName) != null){\r\n            return tobeSeeded.seed(CropSeeds.getByName(seedName));\r\n        }\r\n\r\n        if(SeedType.getByName(seedName) != null){\r\n            return tobeSeeded.seed(SeedType.getByName(seedName));\r\n        }\r\n\r\n        return new Result(false,\"no seed found with this name\");\r\n    }\r\n\r\n    public static Result fertilize(String fertilizerName, Position position) {\r\n        Tile goalTile = App.currentGame.getTile(position.x,position.y);\r\n        if(goalTile.getObjectInTile() == null) return new Result(false,\"goal tile is empty\");\r\n        if(!goalTile.getObjectInTile().getClass().equals(PloughedPlace.class))\r\n            return new Result(false,\"goal tile is not a PloughedPlace\");\r\n        PloughedPlace goalPlace = (PloughedPlace) goalTile.getObjectInTile();\r\n        if(fertilizerName.equals(\"water fertilizer\")){\r\n            return goalPlace.getCurrentState().fertilize(Fertilizer.Water);\r\n        }\r\n        else if(fertilizerName.equals(\"growth fertilizer\")){\r\n            return goalPlace.getCurrentState().fertilize(Fertilizer.Growth);\r\n        }\r\n        else {\r\n            return new Result(false,\"fertilizer not found\");\r\n        }\r\n    }\r\n\r\n    public static Result plantMixedSeed(int dx,int dy) {\r\n\r\n        CropSeeds randomSeed = MixedSeedCrop.getRandomSeed(App.currentGame.getDateAndTime().getSeason());\r\n\r\n        return plant(randomSeed.name(), dx, dy); // if incorrect errors are shown you should check plant method\r\n    }\r\n\r\n\r\n    public static Result showPlant(int x, int y) {\r\n        Position position = new Position(x, y);\r\n        if(position.outOfBounds()) {\r\n            return new Result(false,\"this position is out of bounds!\");\r\n        }\r\n        Tile tile = App.currentGame.getMap().getTile(position);\r\n        if(!tile.getObjectInTile().getClass().equals(PloughedPlace.class))\r\n            return new Result(false,\"this is not a ploughed tile!\");\r\n        PloughedPlace toBeShown = (PloughedPlace) tile.getObjectInTile();\r\n\r\n        if(!toBeShown.hasTreeOrCrop())\r\n            return new Result(false,\"there is not any plant here!\");\r\n        return new Result(true,toBeShown.printInfo());\r\n\r\n    }\r\n\r\n    public static Result placeItem(String itemName, Position position) {\r\n        return null;\r\n    }\r\n\r\n\r\n    public static Result askMarriage(String username, String ringName) {\r\n        return null;\r\n    }\r\n\r\n    public static Result giftNPC(String NPCName, String itemName) {\r\n        return null;\r\n    }\r\n    public static Result questLists() {\r\n        return null;\r\n    }\r\n    public static Result finishQuest(int index) {\r\n        return null;\r\n    }\r\n    public static Result ShowRecipe() {\r\n        Player player = getCurrentPlayer();\r\n        for (CraftItem availableCraft : player.getAvailableCrafts()) {\r\n            System.out.println(availableCraft.getCraftItemType().recipe);\r\n        }\r\n        return null;\r\n    }\r\n    public static Result crafting(String craftingName) {\r\n        Player player = App.currentGame.getCurrentPlayer();\r\n        boolean find = false;\r\n        for (BackPackable backPackable : player.getInventory().getItems().keySet()) {\r\n            if (backPackable.getName().equals(craftingName)) {\r\n                find = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!find && player.getInventory().getItems().size()==player.getInventory().getCapacity()){\r\n            return new Result(false , \"your inventory is full!\");\r\n        }\r\n        CraftItem crafting = null;\r\n        for (CraftItem availableCraft : player.getAvailableCrafts()) {\r\n            if(availableCraft.getName().equals(craftingName)){\r\n                crafting = availableCraft;\r\n                for (BackPackable backPackable : availableCraft.getCraftItemType().ingredients.keySet()) {\r\n                    int num = availableCraft.getCraftItemType().ingredients.get(backPackable);\r\n                    for (BackPackable packable : player.getInventory().getItems().keySet()) {\r\n                        int number = player.getInventory().getItemCount(packable.getName());\r\n                        if(packable.getName().equals(backPackable.getName())){\r\n                            if (number < num) {\r\n                                return new Result(false , \"you dont have enough ingredients!\");\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        if(crafting == null)\r\n            return new Result(false,\"craft item not available\");\r\n        for (BackPackable backPackable : crafting.getCraftItemType().ingredients.keySet()) {\r\n            int num = player.getInventory().getItems().get(backPackable);\r\n            for (BackPackable temp : player.getInventory().getItems().keySet()) {\r\n                int number = player.getInventory().getItems().get(temp);\r\n                if(backPackable.getName().equals(temp.getName())){\r\n                    player.getInventory().getItems().put(temp, number-num);\r\n                }\r\n            }\r\n        }\r\n        player.getInventory().getItems().put(crafting , player.getInventory().getItems().getOrDefault(crafting, 0) + 1);\r\n        player.setEnergy(player.getEnergy()-2);\r\n        return new Result(true,\"craft make successfully\");\r\n    }\r\n    public static Result PlaceItem(String itemName, String x , String y) {\r\n        itemName = itemName.trim().toLowerCase();\r\n        Player player = App.currentGame.getCurrentPlayer();\r\n        BackPackable item = null;\r\n        for (BackPackable backPackable : player.getInventory().getItems().keySet()) {\r\n            if (backPackable.getName().equals(itemName)) {\r\n                item = backPackable;\r\n            }\r\n        }\r\n        if(item == null){\r\n            return new Result(false , \"you dont have this item\");\r\n        }\r\n        Tile tile = null;\r\n        switch (x) {\r\n            case \"1\":\r\n                switch (y){\r\n                    case \"1\":\r\n                        tile = new Tile(player.getPosition().x+1 , player.getPosition().y+1);\r\n                        break;\r\n                    case \"-1\":\r\n                        tile = new Tile(player.getPosition().x+1 , player.getPosition().y-1);\r\n                        break;\r\n                    case \"0\":\r\n                        tile = new Tile(player.getPosition().x+1 , player.getPosition().y);\r\n                        break;\r\n                    default:\r\n                        return new Result(false , \"unknown direction\");\r\n                }\r\n                break;\r\n            case \"-1\":\r\n                switch (y){\r\n                    case \"1\":\r\n                        tile = new Tile(player.getPosition().x-1 , player.getPosition().y+1);\r\n                        break;\r\n                    case \"-1\":\r\n                        tile = new Tile(player.getPosition().x-1 , player.getPosition().y-1);\r\n                        break;\r\n                    case \"0\":\r\n                        tile = new Tile(player.getPosition().x-1 , player.getPosition().y);\r\n                        break;\r\n                    default:\r\n                        return new Result(false , \"unknown direction\");\r\n                }\r\n                break;\r\n            case \"0\":\r\n                switch (y){\r\n                    case \"1\":\r\n                        tile = new Tile(player.getPosition().x , player.getPosition().y+1);\r\n                        break;\r\n                    case \"-1\":\r\n                        tile = new Tile(player.getPosition().x , player.getPosition().y-1);\r\n                        break;\r\n                    case \"0\":\r\n                        tile = new Tile(player.getPosition().x , player.getPosition().y);\r\n                        break;\r\n                    default:\r\n                        return new Result(false , \"unknown direction\");\r\n                }\r\n                break;\r\n            default:\r\n                return new Result(false , \"unknown direction\");\r\n        }\r\n        player.getInventory().getItems().remove(item);\r\n        tile.setObjectInTile(item);\r\n        return new Result(true , \"Item placed successfully\");\r\n    }\r\n    public static Result UseArtisan(String artisanName , String itemName) {\r\n        artisanName = artisanName.trim().toLowerCase();\r\n        itemName = itemName.trim().toLowerCase();\r\n        Player player = App.currentGame.getCurrentPlayer();\r\n        CraftItem artisan = null;\r\n        for (BackPackable backPackable : player.getInventory().getItems().keySet()) {\r\n            if (backPackable.getName().equals(artisanName)) {\r\n                artisan = (CraftItem) backPackable;\r\n                break;\r\n            }\r\n        }\r\n        if (artisan == null) {\r\n            return new Result(false,\"artisan item not available\");\r\n        }\r\n        ArtisanItem artisanItem = null;\r\n        switch (artisanName) {\r\n            case \"\":\r\n                artisanItem = new ArtisanItem(ArtisanItemType.HONEY);\r\n                break;\r\n            case \"milk\":\r\n                artisanItem = new ArtisanItem(ArtisanItemType.CHEESE_MILK);\r\n                break;\r\n            case \"large milk\":\r\n                artisanItem = new ArtisanItem(ArtisanItemType.CHEESE_LARGE_MILK);\r\n                break;\r\n            case \"goat milk\":\r\n                artisanItem = new ArtisanItem(ArtisanItemType.GOAT_CHEESE_MILK);\r\n                break;\r\n            case \"large goat milk\":\r\n                artisanItem = new ArtisanItem(ArtisanItemType.GOAT_CHEESE_LARGE_MILK);\r\n                break;\r\n            case \"wheat\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.BEER);\r\n                break;\r\n            case \"rice\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.VINEGAR);\r\n                break;\r\n            case \"coffee been\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.COFFEE);\r\n                break;\r\n            case \"juice\" :\r\n                // must change\r\n                artisanItem = new ArtisanItem(ArtisanItemType.JUICE);\r\n                break;\r\n            case \"honey\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.MEAD);\r\n                break;\r\n            case \"hops\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.PALE_ALE);\r\n                break;\r\n            case \"wine\" :\r\n                // must change\r\n                artisanItem = new ArtisanItem(ArtisanItemType.WINE);\r\n                break;\r\n            case \"common mushroom\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.DRIED_COMMON_MUSHROOM);\r\n                break;\r\n            case \"red mushroom\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.DRIED_RED_MUSHROOM);\r\n                break;\r\n            case \"purple mushroom\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.DRIED_PURPLE_MUSHROOM);\r\n                break;\r\n            case \"dried fruit\" :\r\n                // must change\r\n                artisanItem = new ArtisanItem(ArtisanItemType.DRIED_FRUIT);\r\n                break;\r\n            case \"grapes\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.RAISINS);\r\n                break;\r\n            case \"coal\":\r\n                artisanItem = new ArtisanItem(ArtisanItemType.COAL);\r\n                break;\r\n            case \"rabbit wool\":\r\n                artisanItem = new ArtisanItem(ArtisanItemType.CLOTH_RABBIT);\r\n                break;\r\n            case \"sheep wool\":\r\n                artisanItem = new ArtisanItem(ArtisanItemType.CLOTH_SHEEP);\r\n                break;\r\n            case \"egg\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.MAYONNAISE_EGG);\r\n                break;\r\n            case \"large egg\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.MAYONNAISE_LARGE_EGG);\r\n                break;\r\n            case \"dinosaur egg\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.DINOSAUR_MAYONNAISE);\r\n                break;\r\n            case \"duck egg\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.DUCK_MAYONNAISE);\r\n                break;\r\n            case \"sunflower\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.OIL_SUNFLOWER);\r\n                break;\r\n            case \"sunflower seed\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.OIL_SUNFLOWER_SEED);\r\n                break;\r\n            case \"corn\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.OIL_CORN);\r\n                break;\r\n            case \"truffle\"   :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.TRUFFLE_OIL);\r\n                break;\r\n            case \"pickles\":\r\n                artisanItem = new ArtisanItem(ArtisanItemType.PICKLES);\r\n                break;\r\n            case \"jelly\" :\r\n                artisanItem = new ArtisanItem(ArtisanItemType.JELLY);\r\n                break;\r\n            case \"fish smoker\":\r\n                artisanItem = new ArtisanItem(ArtisanItemType.SMOKED_FISH);\r\n                break;\r\n            case \"furnace\":\r\n                artisanItem = new ArtisanItem(ArtisanItemType.METAL_BAR);\r\n                break;\r\n            default:\r\n                return new Result(false , \"Artisan item not available\");\r\n        }\r\n        if (artisanItem.getName().equals(\"honey\")){\r\n            Game game = App.currentGame;\r\n            artisanItem.setHour(game.getDateAndTime().getHour());\r\n            artisanItem.setDay(game.getDateAndTime().getDay());\r\n            player.getArtisanItems().add(artisanItem);\r\n            return new Result(true , \"Artisan item made successfully\");\r\n        }\r\n        for (BackPackable backPackable : player.getInventory().getItems().keySet()) {\r\n            if (backPackable.getName().equals(artisanItem.getName())) {\r\n                if(artisanItem.getArtisanItemType().ingredients.getName().equals(backPackable.getName())) {\r\n                    if (player.getInventory().getItemCount(backPackable.getName())<artisanItem.getArtisanItemType().number) {\r\n                        return new Result(false , \"You cant made this artisan item\");\r\n                    }\r\n                    Game game = App.currentGame;\r\n                    artisanItem.setHour(game.getDateAndTime().getHour());\r\n                    artisanItem.setDay(game.getDateAndTime().getDay());\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        player.getArtisanItems().add(artisanItem);\r\n        return new Result(true , \"Artisan item made successfully\");\r\n    }\r\n    public static Result GetArtisan(String artisanName) {\r\n        Player player = App.currentGame.getCurrentPlayer();\r\n        ArtisanItem temp = null;\r\n        for (ArtisanItem artisanItem : player.getArtisanItems()) {\r\n            if (artisanItem.getName().equals(artisanName)) {\r\n                temp = artisanItem;\r\n            }\r\n        }\r\n        if (temp == null) {\r\n            return new Result(false, \"Artisan item not found\");\r\n        }\r\n        Game game = App.currentGame;\r\n        if (temp.getArtisanItemType().productionTimeInHours==0){\r\n            if (temp.getDay()>game.getDateAndTime().getDay()) {\r\n                player.getInventory().getItems().put(temp , 1);\r\n                player.getArtisanItems().remove(temp);\r\n                return new Result(true , \"You receive Artisan item successfully\");\r\n            }\r\n            return new Result(false, \"Artisan item is not ready\");\r\n        }\r\n        int hour = 0;\r\n        hour += (game.getDateAndTime().getHour()-temp.getHour());\r\n        hour += (game.getDateAndTime().getDay()-temp.getDay())*24;\r\n        if(temp.getArtisanItemType().productionTimeInHours>hour) {\r\n            return new Result(false, \"Artisan item is not ready\");\r\n        }\r\n        player.getInventory().getItems().put(temp , 1);\r\n        player.getArtisanItems().remove(temp);\r\n        return new Result(true , \"You receive Artisan item successfully\");\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/controllers/GameMenuController.java b/src/main/java/controllers/GameMenuController.java
--- a/src/main/java/controllers/GameMenuController.java	(revision c85905f21fa3eabeda08b22f497a86c9a08cda43)
+++ b/src/main/java/controllers/GameMenuController.java	(date 1746900083441)
@@ -540,6 +540,11 @@
         return plant(randomSeed.name(), dx, dy); // if incorrect errors are shown you should check plant method
     }
 
+    public static Result meetNPC(String npcName) {
+        // TODO : first Default NPC and then this method
+        return null;
+    }
+
 
     public static Result showPlant(int x, int y) {
         Position position = new Position(x, y);
Index: src/main/java/models/npcs/NPC.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package models.npcs;\r\n\r\nimport models.App;\r\nimport models.Player;\r\nimport models.map.Tile;\r\nimport models.time.Season;\r\nimport models.tools.BackPackable;\r\nimport models.weather.WeatherManagement;\r\nimport models.weather.WeatherOption;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\n\r\npublic class NPC {\r\n    protected String name;\r\n    protected String job;\r\n\r\n    private Tile homeLocation;\r\n\r\n    protected ArrayList<String> dialogues = new ArrayList<>();\r\n\r\n    protected ArrayList<BackPackable> favourites = new ArrayList<>();\r\n\r\n    protected ArrayList<Boolean> questsAvailability = new ArrayList<>();\r\n    protected HashMap<BackPackable, Integer> quests = new HashMap<>();\r\n    protected HashMap<BackPackable, Integer> rewards = new HashMap<>();\r\n\r\n    protected HashMap<Player, NPCFriendShip> friendships = new HashMap<>();\r\n\r\n    public NPC(String name, String job, Tile homeLocation) {\r\n        this.name = name;\r\n        this.job = job;\r\n        this.homeLocation = homeLocation;\r\n    }\r\n\r\n    public String meet(Player player) {\r\n        NPCFriendShip fs = friendships.computeIfAbsent(player, k -> new NPCFriendShip());\r\n        if (!fs.hasTalkedToday()) {\r\n            fs.addPoints(20);\r\n            fs.markTalked();\r\n        }\r\n\r\n\r\n        StringBuilder message = new StringBuilder();\r\n\r\n        message.append(getHiBasedOnFriendShipLevel(fs));\r\n\r\n        message.append(\"it's \")\r\n                .append(getWeatherDescriptor(App.currentGame.getWeather().getCurrentWeather()))\r\n                .append(\" \")\r\n                .append(getTimeOfDayPhrase())\r\n                .append(\" of \")\r\n                .append(getSeasonPhrase())\r\n                .append(\", isn't it?\");\r\n\r\n        return message.toString();\r\n    }\r\n\r\n    private String getHiBasedOnFriendShipLevel(NPCFriendShip fs) {\r\n        switch (fs.getLevel()) {\r\n            case 0: return \"Hello, \";\r\n            case 1: return \"Hi my friend, \";\r\n            case 2: return \"Hi bro, \";\r\n            default: return \"Hey bestie, \";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a short weather descriptor, e.g. \"good sunny\", \"horrible storm\".\r\n     */\r\n    private String getWeatherDescriptor(WeatherOption weather) {\r\n        switch (weather) {\r\n            case SUNNY: return \"a good sunny\";\r\n            case SNOW:  return \"a snowy\";\r\n            case RAINY: return \"a rainy\";\r\n            case STORM: return \"a stormy\";\r\n            default:    return \"nice\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determines time-of-day phrase based on local time.\r\n     * @return one of \"morning\", \"afternoon\", \"evening\", \"night\"\r\n     */\r\n    private String getTimeOfDayPhrase() {\r\n        int hour = App.currentGame.getDateAndTime().getHour();\r\n        if (hour < 6) return \"night\";\r\n        if (hour < 12) return \"morning\";\r\n        if (hour < 18) return \"afternoon\";\r\n        return \"day\";\r\n    }\r\n\r\n    private String getSeasonPhrase() {\r\n        Season season = App.currentGame.getDateAndTime().getSeason();\r\n        return season.displaySeason();\r\n    }\r\n\r\n    public void gift(Player player, BackPackable item) {\r\n\r\n    }\r\n\r\n    public void showQuests() {\r\n\r\n    }\r\n    public void finishQuest(BackPackable item) {\r\n\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/models/npcs/NPC.java b/src/main/java/models/npcs/NPC.java
--- a/src/main/java/models/npcs/NPC.java	(revision c85905f21fa3eabeda08b22f497a86c9a08cda43)
+++ b/src/main/java/models/npcs/NPC.java	(date 1746907090379)
@@ -5,6 +5,7 @@
 import models.map.Tile;
 import models.time.Season;
 import models.tools.BackPackable;
+import models.tools.Tool;
 import models.weather.WeatherManagement;
 import models.weather.WeatherOption;
 
@@ -14,16 +15,11 @@
 public class NPC {
     protected String name;
     protected String job;
-
     private Tile homeLocation;
 
-    protected ArrayList<String> dialogues = new ArrayList<>();
-
     protected ArrayList<BackPackable> favourites = new ArrayList<>();
 
-    protected ArrayList<Boolean> questsAvailability = new ArrayList<>();
-    protected HashMap<BackPackable, Integer> quests = new HashMap<>();
-    protected HashMap<BackPackable, Integer> rewards = new HashMap<>();
+    protected HashMap<Quest,Integer> questTemplates = new HashMap<>();
 
     protected HashMap<Player, NPCFriendShip> friendships = new HashMap<>();
 
@@ -34,7 +30,7 @@
     }
 
     public String meet(Player player) {
-        NPCFriendShip fs = friendships.computeIfAbsent(player, k -> new NPCFriendShip());
+        NPCFriendShip fs = friendships.computeIfAbsent(player, k -> new NPCFriendShip(this,player));
         if (!fs.hasTalkedToday()) {
             fs.addPoints(20);
             fs.markTalked();
@@ -65,9 +61,6 @@
         }
     }
 
-    /**
-     * Returns a short weather descriptor, e.g. "good sunny", "horrible storm".
-     */
     private String getWeatherDescriptor(WeatherOption weather) {
         switch (weather) {
             case SUNNY: return "a good sunny";
@@ -78,10 +71,6 @@
         }
     }
 
-    /**
-     * Determines time-of-day phrase based on local time.
-     * @return one of "morning", "afternoon", "evening", "night"
-     */
     private String getTimeOfDayPhrase() {
         int hour = App.currentGame.getDateAndTime().getHour();
         if (hour < 6) return "night";
@@ -96,7 +85,25 @@
     }
 
     public void gift(Player player, BackPackable item) {
+        if (item instanceof Tool) {
+            throw new IllegalArgumentException("Cannot gift tools to NPCs");
+        }
+        NPCFriendShip friendShip = friendships.computeIfAbsent(player, k -> new NPCFriendShip(this,player));
+        int points = 0;
+        if (!friendShip.hasGiftedToday()) {
+            friendShip.addPoints(50);
+            friendShip.markGifted();
+        }
+        if (favourites.contains(item)) {
+            friendShip.addPoints(150);
+        }
+        friendShip.addPoints(points);
+    }
 
+    public void addQuest(BackPackable quest,int questAmount, BackPackable reward, int rewardAmount) {
+    }
+
+    public void activateQuest(){
     }
 
     public void showQuests() {
@@ -105,4 +112,6 @@
     public void finishQuest(BackPackable item) {
 
     }
-}
\ No newline at end of file
+
+}
+
Index: src/main/java/models/npcs/Quest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/models/npcs/Quest.java b/src/main/java/models/npcs/Quest.java
new file mode 100644
--- /dev/null	(date 1746907414958)
+++ b/src/main/java/models/npcs/Quest.java	(date 1746907414958)
@@ -0,0 +1,34 @@
+package models.npcs;
+
+import models.tools.BackPackable;
+
+public class Quest {
+    BackPackable request;
+    BackPackable reward;
+    int requestAmount;
+    int rewardAmount;
+
+    public Quest(BackPackable request, BackPackable reward, int requestAmount, int rewardAmount) {
+        this.request = request;
+        this.reward = reward;
+        this.requestAmount = requestAmount;
+        this.rewardAmount = rewardAmount;
+    }
+
+    public BackPackable getRequest() {
+        return request;
+    }
+
+    public BackPackable getReward() {
+        return reward;
+    }
+
+    public int getRewardAmount() {
+        return rewardAmount;
+    }
+
+    public int getRequestAmount() {
+        return requestAmount;
+    }
+
+}
